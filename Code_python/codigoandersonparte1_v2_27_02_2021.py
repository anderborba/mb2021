# -*- coding: utf-8 -*-
"""CodigoAndersonParte1_v2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/126cLe_0IG4OHRYsVFj47gcgnm754SbLt
"""

## Importa as bibliotecas iniciais a serem utilizadas
import numpy as np
import scipy.io as sio
from skimage import exposure
import matplotlib as mpl
import matplotlib.pyplot as plt
import math
from scipy.optimize import minimize
from scipy.optimize import optimize
from scipy.optimize import dual_annealing
from scipy import optimize
import scipy.special as sp
#
#import rpy2
#from rpy2.robjects.packages import importr
#
#from rpy2.robjects.vectors import FloatVector
#from rpy2.robjects.packages import importr
#import rpy2.rinterface as ri

#
from mpl_toolkits.mplot3d import Axes3D
#import matplotlib.pyplot as plt
from matplotlib import cm
from matplotlib.ticker import LinearLocator, FormatStrFormatter
## Define a imagem a ser processada
def select_data():
    print("Select the image to be processed:")
    print("1.Flevoland - area 1")
    print("2.San Francisco")
    opcao=int(input("type the option:"))
    if opcao==1:
        imagem="/home/aborba/github/mb2021/Data/AirSAR_Flevoland_Enxuto.mat"
        ## Valores ajustados visualmente - precisa definir o valor do centro da rea corretamente
        dx=278

        dy=64
    else:
        imagem="/home/aborba/bm2021/Data/SanFrancisco_Bay.mat"
        dx=50
        dy=-195
    ## Raio usado nas radias
    RAIO = 120
    ## AAB mudei o raio para ficar igual ao matlab
    ## Numero de raios utilizado na definicao de bordas para circunferencia completa
    NUM_RAIOS=100
    ## angulo inicial para gerar as radiais
    alpha_i=0.0
    ## angulo final para gerar as radiais
    alpha_f=2*np.pi
    ## ajusta o numero de raios de acordo com o angulo
    if (alpha_f-alpha_i)!=(2*np.pi):
        NUM_RAIOS=int(NUM_RAIOS*(alpha_f-alpha_i)/(2*np.pi))

    return imagem, dx, dy, RAIO, NUM_RAIOS, alpha_i, alpha_f
## Le uma imagem no formato mat
def le_imagem(img_geral):
    img=sio.loadmat(img_geral)
    img_dat=img['S']
    img_dat=np.squeeze(img_dat)
    img_shp=img_dat.shape
    ## print(img_shp)
    ncols=img_shp[1]
    nrows=img_shp[0]
    nc=img_shp[len(img_shp)-1]
    return img_dat, nrows, ncols, nc
## Separa os canais e retorn uma imagem de visualizacao
def show_Pauli(data, index, control):
    Ihh = np.real(data[:,:,0])
    Ihv = np.real(data[:,:,1])
    Ivv = np.real(data[:,:,2])
    Ihh=np.sqrt(np.abs(Ihh))
    Ihv=np.sqrt(np.abs(Ihv))/np.sqrt(2)
    Ivv=np.sqrt(np.abs(Ivv))
    R = np.abs(Ihh - Ivv)
    G = (2*Ihv)
    B =  np.abs(Ihh + Ivv)
    R = exposure.equalize_hist(R)
    G = exposure.equalize_hist(G)
    B = exposure.equalize_hist(B)
    II = np.dstack((R,G,B))
    HSV = mpl.colors.rgb_to_hsv(II)
    Heq = exposure.equalize_hist(HSV[:,:,2])
    HSV_mod = HSV
    HSV_mod[:,:,2] = Heq
    Pauli_Image= mpl.colors.rgb_to_hsv(HSV_mod)
    return Pauli_Image

## Define as radiais
def define_radiais(r, num_r, dx, dy, nrows, ncols, start, end):
    x0 = ncols / 2 - dx
    y0 = nrows / 2 - dy
    t = np.linspace(start, end, num_r, endpoint=True)
    x = x0 + r * np.cos(t)
    y = y0 + r * np.sin(t)
    xr= np.round(x)
    yr= np.round(y)
    return x0, y0, xr, yr

## Bresenham
def bresenham(x0, y0, xf, yf):
    x=xf-x0
    y=yf-y0
    m=y*1.0/x
    ## Se m < 0 entao esta no 2o ou 4o quadrante
    if m<0:
        ## Se |m| <= 1 entao esta no 4o ou no 8o octante
        if abs(m)<= 1:
            ## Se x > 0 entao esta no 8o octante
            if x>0:
                y=y*-1
                xp,yp=bresenham_FirstOctante(x,y)
                yp=list(np.asarray(yp)*-1)
            ## senao esta no 4o octante
            else:
                x=x*-1
                xp,yp=bresenham_FirstOctante(x,y)
                xp=list(np.asarray(xp)*-1)
        ## senao esta no 3o ou no 7o octante
        else:
            ## Se y > 0 entao esta no 3o octante
            if y>0:
                x=x*-1
                x,y = y,x
                xp,yp=bresenham_FirstOctante(x,y)
                xp,yp = yp,xp
                xp=list(np.asarray(xp)*-1)
            ## senao esta no 7o octante
            else:
                y=y*-1
                x,y = y,x
                xp,yp=bresenham_FirstOctante(x,y)
                xp,yp = yp,xp
                yp=list(np.asarray(yp)*-1)
    ## senao esta no 1o quadrante ou no 3o quadrante
    else:
        ## Se |m| <= 1 entao esta no 1o ou no 5o octante
        if abs(m)<= 1:
            ## Se x > 0 entao esta no 1o octante
            if x>0:
                xp,yp=bresenham_FirstOctante(x,y)
            ## senao esta no 5o octante
            else:
                x=x*-1
                y=y*-1
                xp,yp=bresenham_FirstOctante(x,y)
                xp=list(np.asarray(xp)*-1)
                yp=list(np.asarray(yp)*-1)
        ## senao esta no 2o ou no 6o octante
        else:
            ## Se y > 0 entao esta no 2o octante
            if y>0:
                x,y = y,x
                xp,yp=bresenham_FirstOctante(x,y)
                xp,yp = yp,xp
            ## senao esta no 6o octante
            else:
                y=y*-1
                x=x*-1
                x,y = y,x
                xp,yp=bresenham_FirstOctante(x,y)
                xp,yp = yp,xp
                xp=list(np.asarray(xp)*-1)
                yp=list(np.asarray(yp)*-1)
    xp= list(np.asarray(xp) + x0)
    yp= list(np.asarray(yp) + y0)
    return xp, yp

## O algoritmo de bresenham foi implementado baseado no artigo:
## https://www.tutorialandexample.com/bresenhams-line-drawing-algorithm/

def bresenham_FirstOctante(xf, yf):
    x=int(xf)
    y=int(yf)
    xp=[]
    yp=[]
    xp.append(0)
    yp.append(0)
    x_temp=0
    y_temp=0
    pk=2*y-x
    for i in range(x-1):
        ## print(pk)
        if pk<0:
            pk=pk+2*y
            x_temp=x_temp+1
            y_temp=y_temp
        else:
            pk=pk+2*y-2*x
            x_temp=x_temp+1
            y_temp=y_temp+1
        xp.append(int(x_temp))
        yp.append(int(y_temp))
    xp.append(x)
    yp.append(y)
    return xp, yp

## Testa se os pontos extremos dos raios estao fora da imagem
def test_XY(XC, YC, j, tam_Y, tam_X):
    if XC[j]<0:
        X=0
    elif XC[j]>=tam_X:
        X=tam_X-1
    else:
        X=XC[j]
    if YC[j]<0:
        Y=0
    elif YC[j]>=tam_Y:
        Y=tam_Y-1
    else:
        Y=YC[j]
    return int(X), int(Y)

## Desenha os raios e determina os pixels de amostragem usando o algoritmo de bresenham
def desenha_raios(ncols, nrows, nc, RAIO, NUM_RAIOS, img, PI, x0, y0, xr, yr):
    ## Cria vetors e matrizes de apoio
    IT = np.zeros([nrows, ncols])
    const =  5 * np.max(np.max(np.max(PI)))
    MXC = np.zeros([NUM_RAIOS, RAIO])
    MYC = np.zeros([NUM_RAIOS, RAIO])
    MY  = np.zeros([NUM_RAIOS, RAIO, nc])
    for i in range(NUM_RAIOS):
        XC, YC = bresenham(x0, y0, xr[i], yr[i])
        for canal in range(nc):
            Iaux = img[:, :, canal]
            dim = len(XC)
            for j in range(dim - 1):
                X,Y = test_XY(XC, YC, j, nrows, ncols)
                MXC[i][j] = X
                MYC[i][j] = Y
                MY[i][j][canal] = Iaux[Y][X]
                IT[Y][X] = const
                PI[Y][X] = const
    #
    return MXC, MYC, MY, IT, PI
def func_obj_l_L_mu(j, z, n, matdf1, matdf2):
    j = int(np.round(j))
    mue = matdf1[j, 0]
    Le  = matdf1[j, 1]
    mud = matdf2[j, 0]
    Ld  = matdf2[j, 1]
    somaze = sum(z[0: j]) / j
    somalogze = sum(np.log(z[0: j])) / j
    #print(j)
    somazd = sum(z[j: n]) / (n - j)
    somalogzd = sum(np.log(z[j: n])) / (n - j)
    #
    aux1 = Le * np.log(Le)
    aux2 = Le * somalogze
    aux3 = Le * np.log(mue)
    aux4 = np.log(math.gamma(Le))
    aux5 = (Le / mue) *  somaze
    #
    aux6  = Ld * np.log(Ld)
    aux7  = Ld * somalogzd
    aux8  = Ld * np.log(mud)
    aux9  = np.log(math.gamma(Ld))
    aux10 = (Ld / mud) * somazd
    a1 =  aux1 + aux2 - aux3 - aux4 - aux5
    a2 =  aux6 + aux7 - aux8 - aux9 - aux10
    #### Beware! The signal is negative because GenSA finds the point of minimum
    func_obj_l_L_mu = -(j * a1 + (n - j) * a2)
    return func_obj_l_L_mu
#
#def loglike(x, z, j):
#    #
#    aux1 = x[0] * np.log(x[0])
#    aux2 = x[0] * sum(np.log(z[0: j])) / j
#    aux3 = x[0] * np.log(x[1])
#    aux4 = np.log(math.gamma(x[0]))
#    aux5 = (x[0] / x[1]) * sum(z[0: j]) / j
    #### Beware! The signal is negative because BFGS finds the point of minimum
#    ll   = -(aux1 + aux2 - aux3 - aux4 - aux5)
#    return ll
def loglike(x, z, j):
    if np.abs(x[0]) > 100:
        x[0] = 100
    L  = np.abs(x[0])
    mu = np.abs(x[1])
    aux1 = L * np.log(L)
    aux2 = L * sum(np.log(z[0: j])) / j
    aux3 = L * np.log(mu)
    aux4 = np.log(math.gamma(L))
    aux5 = (L / mu) * sum(z[0: j]) / j
    #### Beware! The signal is negative because BFGS finds the point of minimum
    ll   = -(aux1 + aux2 - aux3 - aux4 - aux5)
    #ll   = (x[0] - 1)**2 + (x[1] - 3)**2
    return ll
#
def loglikd(x, z, j, n):
    if np.abs(x[0]) > 100:
        x[0] = 100
    L  = np.abs(x[0])
    mu = np.abs(x[1])
    aux1 = L * np.log(L)
    aux2 = L * sum(np.log(z[j: n])) / (n - j)
    aux3 = L * np.log(mu)
    aux4 = np.log(math.gamma(L))
    aux5 = (L / mu) * sum(z[j: n]) / (n - j)
    #### Beware! The signal is negative because BFGS finds the point of minimum
    ll =  -(aux1 + aux2 - aux3 - aux4 - aux5)
    return ll
#
def which(self):
    try:
        self = list(iter(self))
    except TypeError as e:
        raise Exception("""'which' method can only be applied to iterables.
        {}""".format(str(e)))
    indices = [i for i, x in enumerate(self) if bool(x) == True]
    return(indices)
#
#### Programa principal
#maxLik = importr('maxLik')
#loglike_der_func = ri.rternalize(der_fun_loglike)
## Define a imagem as ser lida
imagem, dx, dy, RAIO, NUM_RAIOS, alpha_i, alpha_f = select_data()
## Le a imagem e retorna a imagem, tamanho da imagem e numero de canais
img, nrows, ncols, nc = le_imagem(imagem)

## print(ncols, nrows, nc)

## CRia a imagem de Pauli e mostra a imagem gerada
PI=show_Pauli(img, 1, 0)

## Define os raios da area
x0, y0, xr, yr=define_radiais(RAIO, NUM_RAIOS, dx, dy, nrows, ncols, alpha_i, alpha_f)
MXC, MYC, MY, IT, PI=desenha_raios(ncols, nrows, nc, RAIO, NUM_RAIOS, img, PI, x0, y0, xr, yr)
#
z = np.zeros(RAIO)
#loglike_func = ri.rternalize(lambda xx:loglike(xx, z, j))
# nc = 9, momentaneamente uso ncanal=3
ncanal = 1
evidencias = np.zeros((NUM_RAIOS, 3))
varx = np.zeros(2)
#varx = FloatVector((-1.2, 1))
for canal in range(ncanal):
#for canal in range(0,1):
    print(canal)
    #for k in range(NUM_RAIOS):
    for k in range(9, 10):
        print(k)
        N = RAIO
        z = MY[k, :, canal]
        zaux = np.zeros(N)
        conta = 0
        for i in range(0, N):
            if z[i] > 0:
                zaux[conta] = z[i]
                conta = conta + 1
            #
        indx  = which(zaux != 0)
        N = int(np.max(indx))
        z =  zaux[1:N]
        matdf1 =  np.zeros((N, 2))
        matdf2 =  np.zeros((N, 2))
        #for j in range(1, (N - 1)):
        #for j in range(1, (N - 1)):
        #    print(j)
        for j in range(9, 10):
            #mue = sum(z[0: j]) / j
            #Le = 4.0
            #lc1 = sum(z[0: j]) / j
            #lc2 = sum(np.log(z[0: j])) / j
            varx[0] = 1
            varx[1] = sum(z[0: j]) / j
            print(z)
            res = minimize(lambda varx:loglike(varx, z, j), \
                  varx, \
                  method="BFGS", \
                  tol = 1e-08, \
                  options={'gtol': 1e-08, \
                           'eps': 1.4901161193847656e-08,\
                           'maxiter': 200, \
                           'disp': False,   \
                           'return_all': True})
            #res = minimize(lambda varx:loglike(varx, z, j), varx, method='BFGS')
            #res = optimize.fmin_bfgs(lambda varx:loglike(varx, z, j), varx, jac = lambda varx:der_fun_L_mu(varx, z, j))
            matdf1[j, 0] = np.abs(res.x[0])
            matdf1[j, 1] = np.abs(res.x[1])
            #mud = sum(z[j: (N + 1)]) / (N - j)
            #Ld = 4.0
            #lc1 = mud
            #lc2 = sum(np.log(z[j: (N + 1)])) / (N - j)
            varx[0] = 4
            varx[1] = sum(z[j: N]) / (N - j)
            res = minimize(lambda varx:loglikd(varx, z, j, N), \
                  varx, \
                  method="BFGS", \
                  tol = 1e-08, \
                  options={'gtol': 1e-08, \
                           'eps': 1.4901161193847656e-08,\
                           'maxiter': 200, \
                           'disp': False,   \
                           'return_all': True, })
            #res = minimize(lambda varx:loglikd(varx, z, j, N), varx, method='BFGS')
            #res = minimize(lambda varx:loglikd(varx, z, j, N), varx, method='BFGS')
            matdf2[j, 0] = np.abs(res.x[0])
            matdf2[j, 1] = np.abs(res.x[1])
#
        lw = [14] * 1
        up = [N - 14] * 1
        ret = dual_annealing(lambda x:func_obj_l_L_mu(x,z, N, matdf1, matdf2), \
              bounds=list(zip(lw, up)), seed=1234)
        evidencias[k, canal] = np.round(ret.x)
#
#plt.figure(figsize=(20*k, 20))
#plt.imshow(IM[:, :, 0])
#plt.show()
